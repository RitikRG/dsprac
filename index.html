<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
<pre>
<h2>Singly Linked List</h2>
<code>
    class Node:
        def __init__(self,val):
            self.val=val
            self.next=None

    class SLL:
        def __init__(self,head_node=None):
            self.head=head_node
        def displayList(self):
            temp=self.head
            while(temp!=None):
                print(temp.val,end=" ")
                temp=temp.next
        def length(self):
            temp=self.head
            l=0
            while(temp!=None):
                l+=1
                temp=temp.next
            return l
        def insertAtBegin(self,val):
            newNode=Node(val)
            newNode.next=self.head
            self.head=newNode
        def insert(self,val,idx):
            if(idx==0):
                self.insertAtBegin(val)
            else:
                newNode=Node(val)
                temp=self.head
                i=0
                while(temp!=None and i&lt;idx):
                    if(i==idx-1):
                        newNode.next=temp.next
                        temp.next=newNode
                        break
                    else:
                        temp=temp.next
                        i+=1
        def insertAtEnd(self,val):
            temp=self.head
            while(temp.next!=None):
                temp=temp.next
            newNode=Node(val)
            temp.next=newNode
        def removeFromBegin(self):
            temp=self.head
            self.head=temp.next
            temp.next=None
        def remove(self,idx):
            if(idx==0):
                self.removeFromBegin()
                return
            else:
                temp=self.head
                prev=None
                if(temp==None):
                    print('EmptyList')
                    return
                else:
                    i=0
                    while(temp!=None and i&lt;idx):
                        prev=temp
                        temp=temp.next
                        i+=1
                    if(temp==None):
                        print("Index out of bounds")
                        return
                    else:
                        prev.next=temp.next
                        temp.next=None
        def find(self, val):
            temp = self.head
            while temp:
                if temp.val == val:
                    return temp
                temp = temp.next
            return None


    n1=Node(1)
    n2=Node(2)
    n3=Node(3)
    n4=Node(4)
    n5=Node(5)

    n1.next=n2
    n2.next=n3
    n3.next=n4
    n4.next=n5

    myList = SLL(n1)
    myList.displayList()
    print()
    myList.insertAtBegin(0)
    myList.displayList()
    print()
    print()
    myList.insert(-1,0)
    myList.insert(6,5)
    myList.displayList()
    print()
    myList.insertAtEnd(13)
    myList.displayList()
    print()
    myList.removeFromBegin()
    myList.displayList()
    print()
    myList.remove(7)
    myList.displayList()
    print()
    myList.remove(2)
    myList.displayList()
    print()
    print(myList.find(6))
    print(myList.find(77))


</code>
</pre>
<pre>
<h2>Doubly Linked List</h2>

class Node:
    def __init__(self,val):
        self.val=val
        self.prev=None
        self.next=None
class DLL:
    def __init__(self,headNode):
        self.head=headNode
    def displayList(self):
        temp=self.head
        if(temp is None):
            print("List is Empty")
        else:
            while(temp is not None):
                print(temp.val,end=" ")
                temp=temp.next
            print()
    def insertAtBegin(self,val):
        temp=self.head
        newNode=Node(val)
        if(temp is None):
            self.head=newNode
        else:
            newNode.next=temp
            temp.prev=newNode
            self.head=newNode
    def insertAtEnd(self,val):
        temp=self.head
        newNode=Node(val)
        if(temp is None):
            self.head=newNode
        else:
            while(temp.next is not None):
                temp=temp.next
            temp.next=newNode
            newNode.prev=temp
    def removeFromBegin(self):
        temp=self.head
        if(temp is None):
            print("Empty List")
        else:
            temp2=temp.next
            if(temp2 is None):
                self.head=None
            else:
                temp.next=None
                temp2.prev=None
                self.head=temp2
    def removeFromEnd(self):
        temp=self.head
        if(temp is None):
            print("List is already empty")
        else:
            while(temp.next is not None):
                temp=temp.next
            temp2=temp.prev
            temp.prev=None
            if(temp2 is None):
                self.head=None
            else:
                temp2.next=None


n1=Node(1)
n2=Node(2)
n3=Node(3)
n4=Node(4)
n5=Node(5)

n1.next=n2
n2.next=n3
n3.next=n4
n4.next=n5

n2.prev=n1
n3.prev=n2
n4.prev=n3
n5.prev=n4

myList=DLL(n1)

myList.displayList()
myList.insertAtBegin(111)
myList.displayList()
myList.insertAtEnd(222)
myList.displayList()
myList.removeFromBegin()
myList.displayList()
myList.removeFromEnd()
myList.displayList()


n8=Node(1)
myList2 = DLL(n8)
myList2.removeFromEnd()
myList2.displayList()

</pre>
<pre>
    <h2>Circular Linked List</h2>

class Node:
def __init__(self,val):
    self.val=val
    self.next=None
class CLL:
    def __init__(self,headNode):
        self.head=headNode
    def display(self):
        if(self.head):
            temp=self.head
            print(temp.val,end=" ")
            temp=temp.next
            while(temp!=self.head):
                print(temp.val,end=" ")
                temp=temp.next
        else:
            print("Empty list")
    def search(self,val):
        if(self.head):
            temp=self.head
            if(temp.val==val):
                return temp
            temp=temp.next
            while(temp!=self.head):
                if(temp.val==val):
                    return temp
                temp=temp.next
            print("Element not present in list")
            return -1
        else:
            print("Empty list")
            return(-1)
    def insertAtBegin(self,val):
        if(self.head):
            newNode=Node(val)
            newNode.next=self.head
            temp=self.head
            if(temp.next):
                while(temp.next!=self.head):
                    temp=temp.next
                temp.next=newNode
            self.head=newNode
        else:
            newNode=Node(val)
            self.head=newNode
    def insertAtEnd(self,val):
        if(self.head):
            newNode=Node(val)
            newNode.next=self.head
            temp=self.head
            while(temp.next!=self.head):
                temp=temp.next
            temp.next=newNode
        else:
            newNode=Node(val)
            self.head=newNode
    def insert(self,val,idx):
        if(idx==0):
            self.insertAtBegin(val)           
        else:
            i=1
            temp=self.head.next
            while(temp!=self.head):
                if(i==idx-1):
                    newNode=Node(val)
                    newNode.next=temp.next
                    temp.next=newNode
                i+=1
                temp=temp.next
    def removeFromBegin(self):
        if(self.head):
            if(self.head.next==self.head):
                self.head=None
            else:
                temp=self.head
                while(temp.next!=self.head):
                    temp=temp.next
                temp.next=self.head.next
                self.head=self.head.next
        else:
            print("list is empty")
    def removeFromEnd(self):
        if(self.head):
            if(self.head.next==self.head):
                self.head=None
            else:
                temp=self.head
                while(temp.next.next!=self.head):
                    temp=temp.next
                temp2=temp.next
                temp.next=self.head
                temp2.next=None
                
        else:
            print("List is empty")
    def remove(self,idx):
        if(self.head):
            if(self.head.next==self.head):
                if(idx==0):
                    self.head=None
                else:
                    print("Index out of bounds")
            else:
                temp=self.head
                i=0
                while(temp.next.next!=self.head and i&lt;idx):
                    if(i==idx-1):
                        break
                    temp=temp.next
                    i+=1
                if(i==idx-1):
                    temp2=temp.next
                    temp.next=temp2.next
                    temp2.next=None
                else:
                    print("index out of bounds")
        else:
            print("List is empty")
n1=Node(1)
n2=Node(2)
n3=Node(3)
n4=Node(4)

n1.next=n2
n2.next=n3
n3.next=n4
n4.next=n1

myll=CLL(n1)
myll.tail=n4

myll.display()
print()
myll.insertAtBegin(5)
myll.display()
print()
myll.insertAtEnd(15)
myll.display()
print()
myll.insert(20,3)
myll.display()
print()
myll.removeFromBegin()
myll.display()
print()
myll.removeFromEnd()
myll.display()
print()
myll.remove(2)
myll.display()
print()
myll.remove(5)
myll.display()
</pre>
<pre>
<h2>Stack</h2>

class Stack:
    def __init__(self):
        self.data=[]
    def isEmpty(self):
        if(len(self.data)==0):
            return True
        return False
    def push(self,val):
        self.data.append(val)
    def pop(self):
        return self.data.pop()
    def peek(self):
        if not self.isEmpty():
            return self.data[-1]
           
    def displayStack(self):
        l=len(self.data)
        i=l-1
        print("Stack Top")
        while(i>=0):
            print(self.data[i])
            i-=1    
        print("Stack Bottom")
    
def precedence(operator):
    if(operator=="^"):
        return 3
    elif(operator=="*" or operator=="/" or operator=="%"):
        return 2
    else:
        return 1

def infixToPostfix(exp):
    result=""
    operatorStack=Stack()
    exp+=')'
    operatorStack.push('(')
    for c in exp:
        if c.isalnum():
            result+=str(c)
        elif c=="(":
            operatorStack.push('(')
        elif c==')':
            while not operatorStack.isEmpty() and operatorStack.peek()!='(':
                result+=operatorStack.pop()
            operatorStack.pop()
        else:
            if operatorStack.peek()=="(":
                operatorStack.push(c)
            else:
                if precedence(operatorStack.peek()) &lt;precedence(c):
                    operatorStack.push(c)
                else:
                    while not operatorStack.isEmpty() and operatorStack.peek()!='(' and precedence(operatorStack.peek())>=precedence(c):
                        result+=operatorStack.pop()
                    operatorStack.push(c)
    return result

def infixToPrefix(exp):
    revExp = ""
    i=len(exp)-1
    while(i>=0):
        if(exp[i]==')'):
            revExp+='('
        elif exp[i]=='(':
            revExp+=')'
        else:
            revExp+=exp[i]
        i-=1
    postFix = infixToPostfix(revExp)
    return postFix[::-1]

print(infixToPostfix("x^y/(5*z)+2"))
print(infixToPrefix("x^y/(5*z)+2"))

</pre>
<pre>
<h2>Queue</h2>

class Queue:
    def __init__(self):
        self.data=[]
    def display(self):
        print("Head-> ",end=" ")
        print(self.data,end=" ")
        print("<- Tail ")
    def enqueue(self,val):
        self.data.append(val)
    def dequeue(self):
        if(len(self.data)==0):
            print("Queue Empty")
        else:
            return self.data.pop(0)
    
myQueue=Queue()
myQueue.enqueue(1)
myQueue.enqueue(2)
myQueue.enqueue(3)
myQueue.enqueue(4)
myQueue.display()
print(myQueue.dequeue())
myQueue.display()

</pre>
<pre>
<h2>Binary Search Tree</h2>

class Node:
    def __init__(self,val):
        self.val=val
        self.left=None
        self.right=None
class BST:
    def __init__(self,rootNode):
        self.root=rootNode
    def insert(self,val,root=None):
        if root==None:
            temp=self.root
        else:
            temp=root
        if(temp is None):
            print('Empty Tree')
        else:
            # Smaller values
            if(temp.val >= val):
                # left subtree
                if(temp.left is None):
                    # If root left empty
                    newNode = Node(val)
                    temp.left=newNode
                else:
                    self.insert(val,temp.left)
            elif temp.val < val:
                # right subtree
                if temp.right is None:
                    newNode=Node(val)
                    temp.right=newNode
                else:
                    self.insert(val,temp.right)
    def search(self,val,root=None):
        if root==None:
            temp=self.root
        else:
            temp=root
        if(temp.val==val):
            return temp
        else:
            if temp.val>val:
                # if present, will be present in the left
                if temp.left is None:
                    return None
                else:
                    return self.search(val,temp.left)
            else:
                # if present, will be present in the right
                if temp.right is None:
                    return None
                else:
                    return self.search(val,temp.right)
    def preorder(self,root="NA"):
        if(root=="NA"):
            temp=self.root
        else:
            temp=root
        if(temp):
            print(temp.val,end=" ")
            self.preorder(temp.left)
            self.preorder(temp.right)
        else:
            return
    def postorder(self,root="NA"):
        if root=="NA":
            temp=self.root
        else:
            temp=root
        if(temp):
            self.postorder(temp.left)
            self.postorder(temp.right)
            print(temp.val,end=" ")
    def inorder(self,root="NA"):
        if root=="NA":
            temp=self.root
        else:
            temp=root
        if(temp):
            self.inorder(temp.left)
            print(temp.val,end=" ")
            self.inorder(temp.right)
    def delete(self,val,root="NA",parent="NA"):
        if root=="NA":
            temp=self.root
        else:
            temp=root
        if(temp):
            if(temp.val==val):
                # Leaf node case
                if(temp.left==None and temp.right==None):
                    # if root node
                    if(parent=="NA"):
                        self.root=None
                    else:
                        if(parent.val>=val):
                            # this means left m hoga
                            parent.left=None
                        else:
                            parent.right=None
                elif (temp.left==None and temp.right!=None) or (temp.left!=None and temp.right==None):
                    # if root node
                    if(parent=="NA"):
                        if(temp.left==None):
                            self.root=temp.right
                            temp.right=None
                        else:
                            self.root=temp.left
                            temp.left=None
                    else:
                        # check if left or right of parent
                        if(parent.val>=val):
                            # check if left subtree or right subtree
                            if(temp.left==None):
                                parent.left=temp.right
                                temp.right=None
                            else:
                                parent.left=temp.left
                                temp.left=None
                        else:
                            # check if left subtree or right subtree
                            if(temp.left==None):
                                parent.right=temp.right
                                temp.right=None
                            else:
                                parent.right=temp.left
                                temp.left=None
                else:
                    # two childerns of the deleting Node

                    # find biggest value in the left subtree
                    replacement=temp.left
                    replacementParent=temp
                    while(replacement.right!=None):
                        replacementParent=replacement
                        replacement=replacement.right
                    
                    if(replacement.left!=None):
                        replacementParent.right=replacement.left
                    if(replacementParent!=temp):
                        replacement.left=temp.left
                        replacement.right=temp.right
                    else:
                        if(replacementParent.right!=None):
                            replacement.right=replacementParent.right
                    replacementParent.left=None
                    replacementParent.right=None
                    if(parent=="NA"):
                        self.root=replacement
                    else:
                        if(parent.val>=val):
                            parent.left=replacement
                        else:
                            parent.right=replacement
            elif temp.val>val:
                self.delete(val,temp.left,temp)
            else:
                self.delete(val,temp.right,temp)
        else:
            print('Node Does Not exist')
n1=Node(1)  
tree=BST(n1)
tree.insert(0)
tree.insert(-1)
tree.insert(10)
tree.insert(5)
tree.insert(-3)
tree.insert(12)

print(tree.search(5))

tree.delete(57)
tree.delete(-3)
tree.delete(10)


tree.preorder()
print()
tree.postorder()
print()
tree.inorder()
</pre>
<pre>
<h2>AVL TREE</h2>

class Node:
    def __init__(self, key):
        self.key = key
        self.left = None
        self.right = None
        self.height = 1  # New node is initially at height 1


class AVLTree:

    def insert(self, root, key):
        # Step 1: Perform normal BST insert
        if not root:
            return Node(key)
        elif key < root.key:
            root.left = self.insert(root.left, key)
        else:
            root.right = self.insert(root.right, key)

        # Step 2: Update height
        root.height = 1 + max(self.getHeight(root.left), self.getHeight(root.right))

        # Step 3: Get balance factor
        balance = self.getBalance(root)

        # Step 4: Balance the tree with rotations if needed

        # Case 1 - Left Left
        if balance > 1 and key < root.left.key:
            return self.rightRotate(root)

        # Case 2 - Right Right
        if balance < -1 and key > root.right.key:
            return self.leftRotate(root)

        # Case 3 - Left Right
        if balance > 1 and key > root.left.key:
            root.left = self.leftRotate(root.left)
            return self.rightRotate(root)

        # Case 4 - Right Left
        if balance < -1 and key < root.right.key:
            root.right = self.rightRotate(root.right)
            return self.leftRotate(root)

        return root

    def leftRotate(self, z):
        y = z.right
        T2 = y.left

        # Perform rotation
        y.left = z
        z.right = T2

        # Update heights
        z.height = 1 + max(self.getHeight(z.left), self.getHeight(z.right))
        y.height = 1 + max(self.getHeight(y.left), self.getHeight(y.right))

        return y

    def rightRotate(self, z):
        y = z.left
        T3 = y.right

        # Perform rotation
        y.right = z
        z.left = T3

        # Update heights
        z.height = 1 + max(self.getHeight(z.left), self.getHeight(z.right))
        y.height = 1 + max(self.getHeight(y.left), self.getHeight(y.right))

        return y

    def getHeight(self, node):
        if not node:
            return 0
        return node.height

    def getBalance(self, node):
        if not node:
            return 0
        return self.getHeight(node.left) - self.getHeight(node.right)

    def inorderTraversal(self, root):
        if not root:
            return []
        return self.inorderTraversal(root.left) + [root.key] + self.inorderTraversal(root.right)

</pre>
<pre>
<h2>Factorial</h2>

def factorial(n):
    if(n&lt;=1):
        return 1
    return n*factorial(n-1)

print(factorial(5))
</pre>
<pre>
<h2>Fibonacci</h2>

def fibon(n,a,b):
    if(n==0):
        return a
    return fibon(n-1,a+b,a)
def fibo(n):
    if(n&lt;=2):
        return 1
    return fibon(n-2,1,1)


    
print(fibo(6))
</pre>
<pre>
<h2>Binary Search</h2>

def binarySearch(arr,val,start,end):
    if(start>end):
        return -1
    mid=int(start+(end-start)/2)
    if(arr[mid]==val):
        return mid
    elif arr[mid]>val:
        return binarySearch(arr,val,start,mid-1)
    else:
        return binarySearch(arr,val,mid+1,end)
    
print(binarySearch([2,3,4,7,8,25,34,58,98,115,200],558,0,10))
</pre>
<pre>
<h2>Reverse a sequence</h2>

def reverse(arr,start,end):
    if(start>end):
        return
    temp=arr[end]
    arr[end]=arr[start]
    arr[start]=temp
    reverse(arr,start+1,end-1)

arr=[1,2,3,4,5,6,7,8,9]
reverse(arr,0,len(arr)-1)
print(arr)
</pre>
<pre>
<h2>Power</h2>

def power(x,n):
    if(n==0):
        return 1
    if(n%2==1):
        result=x
    else:
        result=1
    return result*power(x,n//2)*power(x,n//2)

print(power(2,3))
</pre>
</body>
</html>